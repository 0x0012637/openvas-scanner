
ATTENTION:
  Currently the specification document for OTP 1.0
  is established. Any feature clearified and added to
  ../otp/otp_specification_10.txt is removed here.
  The new specification for OTP is finished once the ntp
  documentation files are empty.


Nessus Transfer Protocol Extensions


These 'extensions' are band-aids for the badly designed protocol.
Yes, I know this is getting more and more complicated, I'm sorry for that. 

Nessus 1.3.x will have a new (nice) protocol


1. The client can send additional preferences :
------------------------------------------------------------------------------
. ntp_opt_show_end  : the server will send the message
	SERVER <|> FINISHED <|> hostname <|> SERVER

  Each time the scan of a single host is done.	



. ntp_keep_communication_alive : the server will not close the communication
 	after the test

. ntp_short_status : change the STATUS message to a shorter one :

	'action:hostname:current:max'
	were 'action' is 'p' (portscan) or 'a' (attack)
	     'hostname' is the current attacked host
	     'current' is the port scanned / plugin used
	     'max' is the limit to which 'current' is going to

  The short status dramatically saves bandwidth between the server and the
  client





2. the LONG_ATTACK message...
------------------------------------------------------------------------------
... is an optional replacement for the ATTACK message. It allows openvasd 
to receive attack arguments that have undefined length (the max length 
used to be 4000 bytes).

The syntax is :

CLIENT <|> LONG_ATTACK
size
target


Where :

	<size> is the number of bytes openvasd should allocate
	<target> is the target (of size <size>). If strlen(target) > size,
	then the communication will be shut.

 

3. The SESSIONS messages
------------------------------------------------------------------------------

If the server sends the preference 'ntp_save_sessions', then it
fully supports sessions saving and restoring.

Note that sessions saving and restoring is considered an experimental
feature as of Nessus 1.0.x


A 'session' is the writing, on the server side, of all the events
that took place during a test. So that if the server or the client
crash, then it's possible for the user to restore a test at the
stage he left.

The following messages are implemented : (and must be sent from
the client side)


3.1 Retrieval of the list of sessions
-------------------------------------


CLIENT <|> SESSIONS_LIST <|> CLIENT

returns the list of sessions, in the following format :

SERVER <|> SESSIONS_LIST
name targets
name targets
.
.
.
<|> SERVER

ie:
SERVER <|> SESSIONS_LIST
20000718-175930 ab.server.com
<|> SERVER

Note that 'targets' will never exceed 4000 bytes. If the original
target selection was, say, 32Kb, then only the first 4kb will
be transmitted by the server (this is not important, as this field
is only designed to help the user to remember which session
does what.



3.2 Deletions of older sessions
-------------------------------

The client may ask the server to delete older sessions. The message
is :

CLIENT <|> SESSION_DELETE <|> name <|> CLIENT

The server will not reply, but will send an ERROR
message if an error occured (ie: file not found).


3.3 Restoration of a session
----------------------------

The client may ask to continue a test where he left it, using
the SESSION_RESTORE message :

CLIENT <|> SESSION_RESTORE <|> name <|> CLIENT

At this point, the server acts as if a new attack
had been started, but instead sends to the client 
the data it saved. The user sees the attack as if
it was happening extremely quickly.


3.6 Options
------------

If the option 'save_session' is set to "yes", then the current
session will be saved on disk. 

If the option "save_empty_sessions" is set to "yes", and if "save_session"
is enabled, then empty sessions will also be saved on disk.

4. KB saving
------------

The following options affect the behavior of openvasd :
save_knowledge_base
	If set to "yes", then the KB saving module is activated

only_test_hosts_whose_kb_we_have
	If set to "yes", then openvasd will skip hosts that don't have
	a KB attached to

only_test_hosts_whose_kb_we_dont_have
	If set to "yes", then openvasd will skip hosts that have a KB
	attached to

kb_restore
	If set to "yes", then the KB of the tested host will be restored
	in memory for the test

kb_dont_replay_scanners
	when kb_restore is set to "yes" and this option is set to "yes",
	then the scanners plugins won't be launched if they have been in
	the past

kb_dont_replay_info_gathering
	same as above, but for information gathering plugins

kb_dont_replay_attacks
	same as above, but for attack plugins

kb_dont_replay_denials
	same as above, but for DoS plugins

kb_max_age 
	maximum age of a KB (in seconds)


6. Per-plugin timeout
---------------------

Starting with Nessus 1.0.7, the user has the ability to set the timeout
of each plugin individualy. The option is :


	timeout.<plugin_id> = <timeout>

ie:
	timeout.10246 = 12
	timeout.10542 = -1

8. Alternative protocol negociation
-----------------------------------

The client may specify additional extensions to the NTP protocol
while logging in. For instance:

< NTP/1.2 >< md5_caching >

Means that the client wants to use NTP/1.2 with the md5cache feature.
The current options are :

. md5_caching		[NOT IMPLEMENTED]


9. md5 caching
------------------------------------

**** This option is not implemented at this time


If the option "md5_caching" is enabled at connection time, then :

- The server sends the message PLUGINS_MD5 to the client at connection 
  time (the replace the message PLUGIN_LIST). The format of this message
  is the following :
  	SERVER <|> PLUGINS_MD5 <|> md5 <|> SERVER
	
  where <md5> is the MD5 sum of the md5 sum of all the plugins.
  
  
- The client can then ask for the list of plugins, by sending the
  message COMPLETE_LIST, defined as below :
  
  	CLIENT <|> COMPLETE_LIST <|> CLIENT

  The server will send the PLUGIN_LIST message.
  If the client does not need anything, it sends the 'GO ON' message
  to the server :
  	CLIENT <|> GO ON <|> CLIENT
	
  And the server will send the PREFERENCES message and the communication
  goes on as in MD5-less connections.
  
  Alternatively, the client can ask for a detailed list of md5, by sending
  the message SEND_PLUGINS_MD5 :
  
  	CLIENT <|> SEND_PLUGINS_MD5 <|> CLIENT
	
  The server then replies with a PLUGINS_MD5 message : 
  
  	SERVER <|> PLUGINS_MD5
	plugname <|> md5
	plugname <|> md5
	.
	.
	.
	<|> SERVER
